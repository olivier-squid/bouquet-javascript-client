/**
 * Bouquet
 * This is Bouquet API
 *
 * OpenAPI spec version: 4.2
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 */

(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(['ApiClient', 'model/AnalyticsQuery', 'model/Bookmark', 'model/Facet', 'model/QueryWorkerJobStatus'], factory);
  } else if (typeof module === 'object' && module.exports) {
    // CommonJS-like environments that support module.exports, like Node.
    module.exports = factory(require('../ApiClient'), require('../model/AnalyticsQuery'), require('../model/Bookmark'), require('../model/Facet'), require('../model/QueryWorkerJobStatus'));
  } else {
    // Browser globals (root is window)
    if (!root.Bouquet) {
      root.Bouquet = {};
    }
    root.Bouquet.AnalyticsApi = factory(root.Bouquet.ApiClient, root.Bouquet.AnalyticsQuery, root.Bouquet.Bookmark, root.Bouquet.Facet, root.Bouquet.QueryWorkerJobStatus);
  }
}(this, function(ApiClient, AnalyticsQuery, Bookmark, Facet, QueryWorkerJobStatus) {
  'use strict';

  /**
   * Analytics service.
   * @module api/AnalyticsApi
   * @version 4.2
   */

  /**
   * Constructs a new AnalyticsApi. 
   * @alias module:api/AnalyticsApi
   * @class
   * @param {module:ApiClient} apiClient Optional API client implementation to use,
   * default to {@link module:ApiClient#instance} if unspecified.
   */
  var exports = function(apiClient) {
    this.apiClient = apiClient || ApiClient.instance;


    /**
     * Callback function to receive the result of the cancelQuery operation.
     * @callback module:api/AnalyticsApi~cancelQueryCallback
     * @param {String} error Error message, if any.
     * @param {'Boolean'} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * cancel the execution of the analysis identified by its QueryID
     * 
     * @param {String} QUERYID this is the AnalysisQuery QueryID
     * @param {module:api/AnalyticsApi~cancelQueryCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link 'Boolean'}
     */
    this.cancelQuery = function(QUERYID, callback) {
      var postBody = null;

      // verify the required parameter 'QUERYID' is set
      if (QUERYID == undefined || QUERYID == null) {
        throw new Error("Missing the required parameter 'QUERYID' when calling cancelQuery");
      }


      var pathParams = {
        'QUERYID': QUERYID
      };
      var queryParams = {
      };
      var headerParams = {
      };
      var formParams = {
      };

      var authNames = ['kraken_auth'];
      var contentTypes = [];
      var accepts = ['application/json'];
      var returnType = 'Boolean';

      return this.apiClient.callApi(
        '/status/{QUERYID}/cancel', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the createBookmark operation.
     * @callback module:api/AnalyticsApi~createBookmarkCallback
     * @param {String} error Error message, if any.
     * @param {module:model/Bookmark} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * create a new bookmark
     * 
     * @param {module:model/AnalyticsQuery} body the analysis query definition
     * @param {String} REFERENCE 
     * @param {String} name the new bookmark name
     * @param {Object} opts Optional parameters
     * @param {String} opts.parent the new bookmark folder, can be /MYBOOKMARKS, /MYBOOKMARKS/any/folders or /SHARED/any/folders
     * @param {module:api/AnalyticsApi~createBookmarkCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/Bookmark}
     */
    this.createBookmark = function(body, REFERENCE, name, opts, callback) {
      opts = opts || {};
      var postBody = body;

      // verify the required parameter 'body' is set
      if (body == undefined || body == null) {
        throw new Error("Missing the required parameter 'body' when calling createBookmark");
      }

      // verify the required parameter 'REFERENCE' is set
      if (REFERENCE == undefined || REFERENCE == null) {
        throw new Error("Missing the required parameter 'REFERENCE' when calling createBookmark");
      }

      // verify the required parameter 'name' is set
      if (name == undefined || name == null) {
        throw new Error("Missing the required parameter 'name' when calling createBookmark");
      }


      var pathParams = {
        'REFERENCE': REFERENCE
      };
      var queryParams = {
        'name': name,
        'parent': opts['parent']
      };
      var headerParams = {
      };
      var formParams = {
      };

      var authNames = ['kraken_auth'];
      var contentTypes = [];
      var accepts = ['application/json'];
      var returnType = Bookmark;

      return this.apiClient.callApi(
        '/analytics/{REFERENCE}', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the createBookmarkFromQuery operation.
     * @callback module:api/AnalyticsApi~createBookmarkFromQueryCallback
     * @param {String} error Error message, if any.
     * @param {module:model/Bookmark} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Create a new bookmark based on a query
     * 
     * @param {String} REFERENCE 
     * @param {String} name the new bookmark name
     * @param {Object} opts Optional parameters
     * @param {String} opts.parent the new bookmark folder, can be /MYBOOKMARKS, /MYBOOKMARKS/any/folders or /SHARED/any/folders
     * @param {Array.<String>} opts.groupBy Define the facets to agroup by the results. Facet can be defined using it&#39;s ID or any valid expression. If empty, the subject default parameters will apply. You can use the * token to extend the subject default parameters.
     * @param {Array.<String>} opts.metrics Define the metrics to compute. Metric can be defined using it&#39;s ID or any valid expression. If empty, the subject default parameters will apply. You can use the * token to extend the subject default parameters.
     * @param {Array.<String>} opts.filters Define the filters to apply to results. A filter must be a valid conditional expression. If no filter is defined, the subject default filters will be applied. You can use the * token to extend the subject default filters instead of replacing.
     * @param {String} opts.period the period defines a dimension or expression of a type date that is used to restrict the timeframe. You can use the __PERIOD expression as a alias to it in other parameters (e.g.: groupBy,orderBy...).
     * @param {Array.<String>} opts.timeframe the timeframe defines the period range to filter. You can use an array of two dates for lower/upper bounds (inclusive). Or some alias like __ALL, __LAST_DAY, __LAST_7_DAYS, __CURRENT_MONTH, __PREVIOUS_MONTH, __CURRENT_YEAR, __PREVIOUS_YEAR
     * @param {Array.<String>} opts.compareTo Activate and define the compare to period. You can use an array of two dates for lower/upper bounds (inclusive). Or some alias like __COMPARE_TO_PREVIOUS_PERIOD, __COMPARE_TO_PREVIOUS_MONTH, __COMPARE_TO_PREVIOUS_YEAR
     * @param {Array.<String>} opts.orderBy Define how to sort the results. You can specify a colun either by it&#39;s index (starting at zero by groupBy, then metrics), or using an expression. Use the function DESC() and ASC() to modify the sort order. The expression must be a column, or at least a hierarchical parent of a column (in that case a groupBy may be added automatically to the query).
     * @param {Array.<String>} opts.rollup Optionaly you can compute rollup for any groupBy column. It must be a valid indexe of a groupBy column or the expression FIRST(N) or LAST(N) to set the rollup position. Index starts at zero. Special value of -1 can be used to compute a grand total.
     * @param {Number} opts.limit limit the resultset size as computed by the database. Note that this is independant from the paging size defined by maxResults.
     * @param {Number} opts.offset offset the resultset first row - usually used with limit to paginate the database. Note that this is independant from the paging defined by startIndex.
     * @param {Array.<String>} opts.beyondLimit exclude some dimensions from the limit
     * @param {Number} opts.maxResults Define the pagination size.
     * @param {Number} opts.startIndex Pagination starting index. Index is zero-based, so use the #count of the last row to view the next page.
     * @param {String} opts.lazy if true, get the analysis only if already in cache, else throw a NotInCacheException; if noError returns a null result if the analysis is not in cache ; else regular analysis (default to false)
     * @param {module:model/String} opts.data define the analysis data output format.
     * @param {Boolean} opts.applyFormatting apply formatting to the output data
     * @param {module:model/String} opts.style define the response style. If HUMAN, the API will try to use natural reference for objects, like &#39;My First Project&#39;, &#39;Account&#39;, &#39;Total Sales&#39;... If MACHINE the API will use canonical references that are invariant, e.g. @&#39;5603ca63c531d744b50823a3bis&#39;. If LEGACY the API will also provide internal compound key to lookup objects in the management API. (default to HUMAN)
     * @param {module:model/String} opts.envelope define the result envelope
     * @param {Number} opts.timeout response timeout in milliseconds. If no timeout set, the method will return according to current job status.
     * @param {String} opts.state 
     * @param {module:api/AnalyticsApi~createBookmarkFromQueryCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/Bookmark}
     */
    this.createBookmarkFromQuery = function(REFERENCE, name, opts, callback) {
      opts = opts || {};
      var postBody = null;

      // verify the required parameter 'REFERENCE' is set
      if (REFERENCE == undefined || REFERENCE == null) {
        throw new Error("Missing the required parameter 'REFERENCE' when calling createBookmarkFromQuery");
      }

      // verify the required parameter 'name' is set
      if (name == undefined || name == null) {
        throw new Error("Missing the required parameter 'name' when calling createBookmarkFromQuery");
      }


      var pathParams = {
        'REFERENCE': REFERENCE
      };
      var queryParams = {
        'name': name,
        'parent': opts['parent'],
        'groupBy': this.apiClient.buildCollectionParam(opts['groupBy'], 'multi'),
        'metrics': this.apiClient.buildCollectionParam(opts['metrics'], 'multi'),
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'multi'),
        'period': opts['period'],
        'timeframe': this.apiClient.buildCollectionParam(opts['timeframe'], 'multi'),
        'compareTo': this.apiClient.buildCollectionParam(opts['compareTo'], 'multi'),
        'orderBy': this.apiClient.buildCollectionParam(opts['orderBy'], 'multi'),
        'rollup': this.apiClient.buildCollectionParam(opts['rollup'], 'multi'),
        'limit': opts['limit'],
        'offset': opts['offset'],
        'beyondLimit': this.apiClient.buildCollectionParam(opts['beyondLimit'], 'multi'),
        'maxResults': opts['maxResults'],
        'startIndex': opts['startIndex'],
        'lazy': opts['lazy'],
        'data': opts['data'],
        'applyFormatting': opts['applyFormatting'],
        'style': opts['style'],
        'envelope': opts['envelope'],
        'timeout': opts['timeout'],
        'state': opts['state']
      };
      var headerParams = {
      };
      var formParams = {
      };

      var authNames = ['kraken_auth'];
      var contentTypes = [];
      var accepts = ['application/json'];
      var returnType = Bookmark;

      return this.apiClient.callApi(
        '/analytics/{REFERENCE}/bookmark', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the exportAnalysis operation.
     * @callback module:api/AnalyticsApi~exportAnalysisCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Export an analysis results
     * 
     * @param {String} REFERENCE 
     * @param {String} filename 
     * @param {Object} opts Optional parameters
     * @param {Array.<String>} opts.groupBy Define the facets to agroup by the results. Facet can be defined using it&#39;s ID or any valid expression. If empty, the subject default parameters will apply. You can use the * token to extend the subject default parameters.
     * @param {Array.<String>} opts.metrics Define the metrics to compute. Metric can be defined using it&#39;s ID or any valid expression. If empty, the subject default parameters will apply. You can use the * token to extend the subject default parameters.
     * @param {Array.<String>} opts.filters Define the filters to apply to results. A filter must be a valid conditional expression. If no filter is defined, the subject default filters will be applied. You can use the * token to extend the subject default filters instead of replacing.
     * @param {String} opts.period the period defines a dimension or expression of a type date that is used to restrict the timeframe. You can use the __PERIOD expression as a alias to it in other parameters (e.g.: groupBy,orderBy...).
     * @param {Array.<String>} opts.timeframe the timeframe defines the period range to filter. You can use an array of two dates for lower/upper bounds (inclusive). Or some alias like __ALL, __LAST_DAY, __LAST_7_DAYS, __CURRENT_MONTH, __PREVIOUS_MONTH, __CURRENT_YEAR, __PREVIOUS_YEAR
     * @param {Array.<String>} opts.compareTo Activate and define the compare to period. You can use an array of two dates for lower/upper bounds (inclusive). Or some alias like __COMPARE_TO_PREVIOUS_PERIOD, __COMPARE_TO_PREVIOUS_MONTH, __COMPARE_TO_PREVIOUS_YEAR
     * @param {Array.<String>} opts.orderBy Define how to sort the results. You can specify a colun either by it&#39;s index (starting at zero by groupBy, then metrics), or using an expression. Use the function DESC() and ASC() to modify the sort order. The expression must be a column, or at least a hierarchical parent of a column (in that case a groupBy may be added automatically to the query).
     * @param {Array.<String>} opts.rollup Optionaly you can compute rollup for any groupBy column. It must be a valid indexe of a groupBy column or the expression FIRST(N) or LAST(N) to set the rollup position. Index starts at zero. Special value of -1 can be used to compute a grand total.
     * @param {Number} opts.limit limit the resultset size as computed by the database. Note that this is independant from the paging size defined by maxResults.
     * @param {Number} opts.offset offset the resultset first row - usually used with limit to paginate the database. Note that this is independant from the paging defined by startIndex.
     * @param {Array.<String>} opts.beyondLimit exclude some dimensions from the limit
     * @param {module:api/AnalyticsApi~exportAnalysisCallback} callback The callback function, accepting three arguments: error, data, response
     */
    this.exportAnalysis = function(REFERENCE, filename, opts, callback) {
      opts = opts || {};
      var postBody = null;

      // verify the required parameter 'REFERENCE' is set
      if (REFERENCE == undefined || REFERENCE == null) {
        throw new Error("Missing the required parameter 'REFERENCE' when calling exportAnalysis");
      }

      // verify the required parameter 'filename' is set
      if (filename == undefined || filename == null) {
        throw new Error("Missing the required parameter 'filename' when calling exportAnalysis");
      }


      var pathParams = {
        'REFERENCE': REFERENCE,
        'filename': filename
      };
      var queryParams = {
        'groupBy': this.apiClient.buildCollectionParam(opts['groupBy'], 'multi'),
        'metrics': this.apiClient.buildCollectionParam(opts['metrics'], 'multi'),
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'multi'),
        'period': opts['period'],
        'timeframe': this.apiClient.buildCollectionParam(opts['timeframe'], 'multi'),
        'compareTo': this.apiClient.buildCollectionParam(opts['compareTo'], 'multi'),
        'orderBy': this.apiClient.buildCollectionParam(opts['orderBy'], 'multi'),
        'rollup': this.apiClient.buildCollectionParam(opts['rollup'], 'multi'),
        'limit': opts['limit'],
        'offset': opts['offset'],
        'beyondLimit': this.apiClient.buildCollectionParam(opts['beyondLimit'], 'multi')
      };
      var headerParams = {
      };
      var formParams = {
      };

      var authNames = ['kraken_auth'];
      var contentTypes = [];
      var accepts = ['application/json'];
      var returnType = null;

      return this.apiClient.callApi(
        '/analytics/{REFERENCE}/export/{filename}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the getFacet operation.
     * @callback module:api/AnalyticsApi~getFacetCallback
     * @param {String} error Error message, if any.
     * @param {module:model/Facet} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Get facet content using the default BB selection
     * 
     * @param {String} REFERENCE 
     * @param {String} FACETID 
     * @param {Object} opts Optional parameters
     * @param {String} opts.q search the facet values using a list of tokens
     * @param {Array.<String>} opts.filters Define the filters to apply to results. A filter must be a valid conditional expression. If empty, the subject default parameters will apply. You can use the * token to extend the subject default parameters.
     * @param {Number} opts.maxResults maximum number of items to return per page
     * @param {Number} opts.startIndex index of the first item to start the page
     * @param {Number} opts.timeout optional timeout in milliseconds
     * @param {module:api/AnalyticsApi~getFacetCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/Facet}
     */
    this.getFacet = function(REFERENCE, FACETID, opts, callback) {
      opts = opts || {};
      var postBody = null;

      // verify the required parameter 'REFERENCE' is set
      if (REFERENCE == undefined || REFERENCE == null) {
        throw new Error("Missing the required parameter 'REFERENCE' when calling getFacet");
      }

      // verify the required parameter 'FACETID' is set
      if (FACETID == undefined || FACETID == null) {
        throw new Error("Missing the required parameter 'FACETID' when calling getFacet");
      }


      var pathParams = {
        'REFERENCE': REFERENCE,
        'FACETID': FACETID
      };
      var queryParams = {
        'q': opts['q'],
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'multi'),
        'maxResults': opts['maxResults'],
        'startIndex': opts['startIndex'],
        'timeout': opts['timeout']
      };
      var headerParams = {
      };
      var formParams = {
      };

      var authNames = ['kraken_auth'];
      var contentTypes = [];
      var accepts = ['application/json'];
      var returnType = Facet;

      return this.apiClient.callApi(
        '/analytics/{REFERENCE}/facets/{FACETID}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the getItem operation.
     * @callback module:api/AnalyticsApi~getItemCallback
     * @param {String} error Error message, if any.
     * @param {Object} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Get an item, can be a Domain or a Bookmark
     * 
     * @param {String} REFERENCE 
     * @param {module:api/AnalyticsApi~getItemCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Object}
     */
    this.getItem = function(REFERENCE, callback) {
      var postBody = null;

      // verify the required parameter 'REFERENCE' is set
      if (REFERENCE == undefined || REFERENCE == null) {
        throw new Error("Missing the required parameter 'REFERENCE' when calling getItem");
      }


      var pathParams = {
        'REFERENCE': REFERENCE
      };
      var queryParams = {
      };
      var headerParams = {
      };
      var formParams = {
      };

      var authNames = ['kraken_auth'];
      var contentTypes = [];
      var accepts = ['application/json'];
      var returnType = Object;

      return this.apiClient.callApi(
        '/analytics/{REFERENCE}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the getStatus operation.
     * @callback module:api/AnalyticsApi~getStatusCallback
     * @param {String} error Error message, if any.
     * @param {Array.<module:model/QueryWorkerJobStatus>} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * get the ongoing status of the analysis identified by its QueryID
     * 
     * @param {String} QUERYID this is the AnalysisQuery QueryID
     * @param {module:api/AnalyticsApi~getStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Array.<module:model/QueryWorkerJobStatus>}
     */
    this.getStatus = function(QUERYID, callback) {
      var postBody = null;

      // verify the required parameter 'QUERYID' is set
      if (QUERYID == undefined || QUERYID == null) {
        throw new Error("Missing the required parameter 'QUERYID' when calling getStatus");
      }


      var pathParams = {
        'QUERYID': QUERYID
      };
      var queryParams = {
      };
      var headerParams = {
      };
      var formParams = {
      };

      var authNames = ['kraken_auth'];
      var contentTypes = [];
      var accepts = ['application/json'];
      var returnType = [QueryWorkerJobStatus];

      return this.apiClient.callApi(
        '/status/{QUERYID}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the listContent operation.
     * @callback module:api/AnalyticsApi~listContentCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * List available content
     * It provides a comprehensive view including projects, domains, folders and bookmarks.You can use it to navigate the entire available content, or access a specific content by defining the parent parameter.The root parents are /PROJECTS for listing projects and domains, /MYBOOKMARKS to list the user bookmarks and folders, and /SHARED to list the shared bookmarks and folders.By default it lists ony the content directly under the parent, but you can set the hierarchy parameter to view content recursively.
     * @param {Object} opts Optional parameters
     * @param {String} opts.parent filter the content under the parent path
     * @param {String} opts.q filter the content by name; q can be a multi-token search string separated by comma
     * @param {module:model/String} opts.hierarchy define the hierarchy mode. FLAT mode return the hierarchy as a flat list, whereas TREE returns it as a folded structure (NIY)
     * @param {module:model/String} opts.visibility filter the result depending on the object visibility (default to VISIBLE)
     * @param {module:model/String} opts.style define the result style. If HUMAN, the API will try to use natural reference for objects, like &#39;My First Project&#39;, &#39;Account&#39;, &#39;Total Sales&#39;... If ROBOT the API will use canonical references that are invariant, e.g. @&#39;5603ca63c531d744b50823a3bis&#39;. If LEGACY the API will also provide internal compound key to lookup objects in the management API. (default to HUMAN)
     * @param {module:model/String} opts.envelope define the result envelope
     * @param {module:api/AnalyticsApi~listContentCallback} callback The callback function, accepting three arguments: error, data, response
     */
    this.listContent = function(opts, callback) {
      opts = opts || {};
      var postBody = null;


      var pathParams = {
      };
      var queryParams = {
        'parent': opts['parent'],
        'q': opts['q'],
        'hierarchy': opts['hierarchy'],
        'visibility': opts['visibility'],
        'style': opts['style'],
        'envelope': opts['envelope']
      };
      var headerParams = {
      };
      var formParams = {
      };

      var authNames = ['kraken_auth'];
      var contentTypes = [];
      var accepts = ['application/json'];
      var returnType = null;

      return this.apiClient.callApi(
        '/analytics', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the postAnalysis operation.
     * @callback module:api/AnalyticsApi~postAnalysisCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Run a new Analysis based on the Bookmark scope
     * 
     * @param {module:model/AnalyticsQuery} body the analysis query definition
     * @param {String} REFERENCE 
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.data define the analysis data format.
     * @param {Boolean} opts.applyFormatting apply formatting to the output data
     * @param {module:model/String} opts.envelope define the result envelope
     * @param {Number} opts.timeout response timeout in milliseconds. If no timeout set, the method will return according to current job status.
     * @param {String} opts.state 
     * @param {module:api/AnalyticsApi~postAnalysisCallback} callback The callback function, accepting three arguments: error, data, response
     */
    this.postAnalysis = function(body, REFERENCE, opts, callback) {
      opts = opts || {};
      var postBody = body;

      // verify the required parameter 'body' is set
      if (body == undefined || body == null) {
        throw new Error("Missing the required parameter 'body' when calling postAnalysis");
      }

      // verify the required parameter 'REFERENCE' is set
      if (REFERENCE == undefined || REFERENCE == null) {
        throw new Error("Missing the required parameter 'REFERENCE' when calling postAnalysis");
      }


      var pathParams = {
        'REFERENCE': REFERENCE
      };
      var queryParams = {
        'data': opts['data'],
        'applyFormatting': opts['applyFormatting'],
        'envelope': opts['envelope'],
        'timeout': opts['timeout'],
        'state': opts['state']
      };
      var headerParams = {
      };
      var formParams = {
      };

      var authNames = ['kraken_auth'];
      var contentTypes = [];
      var accepts = ['application/json'];
      var returnType = null;

      return this.apiClient.callApi(
        '/analytics/{REFERENCE}/query', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the runAnalysis operation.
     * @callback module:api/AnalyticsApi~runAnalysisCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Compute an analysis for the subject
     * 
     * @param {String} REFERENCE 
     * @param {Object} opts Optional parameters
     * @param {Array.<String>} opts.groupBy Define the facets to agroup by the results. Facet can be defined using it&#39;s ID or any valid expression. If empty, the subject default parameters will apply. You can use the * token to extend the subject default parameters.
     * @param {Array.<String>} opts.metrics Define the metrics to compute. Metric can be defined using it&#39;s ID or any valid expression. If empty, the subject default parameters will apply. You can use the * token to extend the subject default parameters.
     * @param {Array.<String>} opts.filters Define the filters to apply to results. A filter must be a valid conditional expression. If no filter is defined, the subject default filters will be applied. You can use the * token to extend the subject default filters instead of replacing.
     * @param {String} opts.period the period defines a dimension or expression of a type date that is used to restrict the timeframe. You can use the __PERIOD expression as a alias to it in other parameters (e.g.: groupBy,orderBy...).
     * @param {Array.<String>} opts.timeframe the timeframe defines the period range to filter. You can use an array of two dates for lower/upper bounds (inclusive). Or some alias like __ALL, __LAST_DAY, __LAST_7_DAYS, __CURRENT_MONTH, __PREVIOUS_MONTH, __CURRENT_YEAR, __PREVIOUS_YEAR
     * @param {Array.<String>} opts.compareTo Activate and define the compare to period. You can use an array of two dates for lower/upper bounds (inclusive). Or some alias like __COMPARE_TO_PREVIOUS_PERIOD, __COMPARE_TO_PREVIOUS_MONTH, __COMPARE_TO_PREVIOUS_YEAR
     * @param {Array.<String>} opts.orderBy Define how to sort the results. You can specify a colun either by it&#39;s index (starting at zero by groupBy, then metrics), or using an expression. Use the function DESC() and ASC() to modify the sort order. The expression must be a column, or at least a hierarchical parent of a column (in that case a groupBy may be added automatically to the query).
     * @param {Array.<String>} opts.rollup Optionaly you can compute rollup for any groupBy column. It must be a valid indexe of a groupBy column or the expression FIRST(N) or LAST(N) to set the rollup position. Index starts at zero. Special value of -1 can be used to compute a grand total.
     * @param {Number} opts.limit limit the resultset size as computed by the database. Note that this is independant from the paging size defined by maxResults.
     * @param {Number} opts.offset offset the resultset first row - usually used with limit to paginate the database. Note that this is independant from the paging defined by startIndex.
     * @param {Array.<String>} opts.beyondLimit exclude some dimensions from the limit
     * @param {Number} opts.maxResults Define the pagination size.
     * @param {Number} opts.startIndex Pagination starting index. Index is zero-based, so use the #count of the last row to view the next page.
     * @param {String} opts.lazy if true, get the analysis only if already in cache, else throw a NotInCacheException; if noError returns a null result if the analysis is not in cache ; else regular analysis (default to false)
     * @param {module:model/String} opts.data define the analysis data output format.
     * @param {Boolean} opts.applyFormatting apply formatting to the output data
     * @param {module:model/String} opts.style define the response style. If HUMAN, the API will try to use natural reference for objects, like &#39;My First Project&#39;, &#39;Account&#39;, &#39;Total Sales&#39;... If MACHINE the API will use canonical references that are invariant, e.g. @&#39;5603ca63c531d744b50823a3bis&#39;. If LEGACY the API will also provide internal compound key to lookup objects in the management API. (default to HUMAN)
     * @param {module:model/String} opts.envelope define the result envelope
     * @param {Number} opts.timeout response timeout in milliseconds. If no timeout set, the method will return according to current job status.
     * @param {String} opts.state 
     * @param {module:api/AnalyticsApi~runAnalysisCallback} callback The callback function, accepting three arguments: error, data, response
     */
    this.runAnalysis = function(REFERENCE, opts, callback) {
      opts = opts || {};
      var postBody = null;

      // verify the required parameter 'REFERENCE' is set
      if (REFERENCE == undefined || REFERENCE == null) {
        throw new Error("Missing the required parameter 'REFERENCE' when calling runAnalysis");
      }


      var pathParams = {
        'REFERENCE': REFERENCE
      };
      var queryParams = {
        'groupBy': this.apiClient.buildCollectionParam(opts['groupBy'], 'multi'),
        'metrics': this.apiClient.buildCollectionParam(opts['metrics'], 'multi'),
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'multi'),
        'period': opts['period'],
        'timeframe': this.apiClient.buildCollectionParam(opts['timeframe'], 'multi'),
        'compareTo': this.apiClient.buildCollectionParam(opts['compareTo'], 'multi'),
        'orderBy': this.apiClient.buildCollectionParam(opts['orderBy'], 'multi'),
        'rollup': this.apiClient.buildCollectionParam(opts['rollup'], 'multi'),
        'limit': opts['limit'],
        'offset': opts['offset'],
        'beyondLimit': this.apiClient.buildCollectionParam(opts['beyondLimit'], 'multi'),
        'maxResults': opts['maxResults'],
        'startIndex': opts['startIndex'],
        'lazy': opts['lazy'],
        'data': opts['data'],
        'applyFormatting': opts['applyFormatting'],
        'style': opts['style'],
        'envelope': opts['envelope'],
        'timeout': opts['timeout'],
        'state': opts['state']
      };
      var headerParams = {
      };
      var formParams = {
      };

      var authNames = ['kraken_auth'];
      var contentTypes = [];
      var accepts = ['application/json'];
      var returnType = null;

      return this.apiClient.callApi(
        '/analytics/{REFERENCE}/query', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the scopeAnalysis operation.
     * @callback module:api/AnalyticsApi~scopeAnalysisCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Provide information about the expressions available in the bookmark scope
     * It also allows to check if a given expression is valid in the scope, and further explore the scope if the expression is an object. Using the offset parameter you can get suggestion at the caret position instead of the complete expression value.
     * @param {String} REFERENCE 
     * @param {Object} opts Optional parameters
     * @param {String} opts.target (optional) if you want the scope for a relation, this identify the target domain
     * @param {String} opts.value (optional) the expression to check and get suggestion for, or null in order to get scope level suggestions
     * @param {Number} opts.offset (optionnal) caret position in the expression value in order to provide relevant suggestions based on the caret position. By default the suggestion are based on the full expression if provided, or else the entire bookmark scope.
     * @param {Array.<module:model/String>} opts.types (optional) the expression type to filter the suggestions. If undefined all valid expression in the context are returned. 
     * @param {Array.<module:model/String>} opts.values (optional) the expression value to filter the suggestions. If undefined all valid expression in the context are returned. 
     * @param {module:model/String} opts.style define the response style. If HUMAN, the API will try to use natural reference for objects, like &#39;My First Project&#39;, &#39;Account&#39;, &#39;Total Sales&#39;... If MACHINE the API will use canonical references that are invariant, e.g. @&#39;5603ca63c531d744b50823a3bis&#39;. If LEGACY the API will also provide internal compound key to lookup objects in the management API. (default to HUMAN)
     * @param {module:api/AnalyticsApi~scopeAnalysisCallback} callback The callback function, accepting three arguments: error, data, response
     */
    this.scopeAnalysis = function(REFERENCE, opts, callback) {
      opts = opts || {};
      var postBody = null;

      // verify the required parameter 'REFERENCE' is set
      if (REFERENCE == undefined || REFERENCE == null) {
        throw new Error("Missing the required parameter 'REFERENCE' when calling scopeAnalysis");
      }


      var pathParams = {
        'REFERENCE': REFERENCE
      };
      var queryParams = {
        'target': opts['target'],
        'value': opts['value'],
        'offset': opts['offset'],
        'types': this.apiClient.buildCollectionParam(opts['types'], 'multi'),
        'values': this.apiClient.buildCollectionParam(opts['values'], 'multi'),
        'style': opts['style']
      };
      var headerParams = {
      };
      var formParams = {
      };

      var authNames = ['kraken_auth'];
      var contentTypes = [];
      var accepts = ['application/json'];
      var returnType = null;

      return this.apiClient.callApi(
        '/analytics/{REFERENCE}/scope', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }

    /**
     * Callback function to receive the result of the viewAnalysis operation.
     * @callback module:api/AnalyticsApi~viewAnalysisCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Generate a dataviz specs from a query
     * 
     * @param {String} REFERENCE 
     * @param {Object} opts Optional parameters
     * @param {String} opts.x set the x axis channel. This must be a valid expression or the special alias __PERIOD to refer to the main period.
     * @param {String} opts.y set the y axis channel. This must be a valid expression.
     * @param {String} opts.color set a series channel, displayed using a color palette. This must be a valid expression.
     * @param {String} opts.size set a series channel, displayed using the marker size. This must be a valid expression.
     * @param {String} opts.column set a facetted channel, displayed as columns. This must be a valid expression.
     * @param {String} opts.row set a facetted channel, displayed as rows. This must be a valid expression.
     * @param {Array.<String>} opts.groupBy Define the facets to agroup by the results. Facet can be defined using it&#39;s ID or any valid expression. If empty, the subject default parameters will apply. You can use the * token to extend the subject default parameters.
     * @param {Array.<String>} opts.metrics Define the metrics to compute. Metric can be defined using it&#39;s ID or any valid expression. If empty, the subject default parameters will apply. You can use the * token to extend the subject default parameters.
     * @param {Array.<String>} opts.filters Define the filters to apply to results. A filter must be a valid conditional expression. If no filter is defined, the subject default filters will be applied. You can use the * token to extend the subject default filters instead of replacing.
     * @param {String} opts.period the period defines a dimension or expression of a type date that is used to restrict the timeframe. You can use the __PERIOD expression as a alias to it in other parameters (e.g.: groupBy,orderBy...).
     * @param {Array.<String>} opts.timeframe the timeframe defines the period range to filter. You can use an array of two dates for lower/upper bounds (inclusive). Or some alias like __ALL, __LAST_DAY, __LAST_7_DAYS, __CURRENT_MONTH, __PREVIOUS_MONTH, __CURRENT_YEAR, __PREVIOUS_YEAR
     * @param {Array.<String>} opts.compareTo Activate and define the compare to period. You can use an array of two dates for lower/upper bounds (inclusive). Or some alias like __COMPARE_TO_PREVIOUS_PERIOD, __COMPARE_TO_PREVIOUS_MONTH, __COMPARE_TO_PREVIOUS_YEAR
     * @param {Array.<String>} opts.orderBy Define how to sort the results. You can specify a colun either by it&#39;s index (starting at zero by groupBy, then metrics), or using an expression. Use the function DESC() and ASC() to modify the sort order. The expression must be a column, or at least a hierarchical parent of a column (in that case a groupBy may be added automatically to the query).
     * @param {Number} opts.limit limit the resultset size as computed by the database. Note that this is independant from the paging size defined by maxResults.
     * @param {Number} opts.offset offset the resultset first row - usually used with limit to paginate the database. Note that this is independant from the paging defined by startIndex.
     * @param {Array.<String>} opts.beyondLimit exclude some dimensions from the limit
     * @param {Number} opts.maxResults paging size
     * @param {Number} opts.startIndex paging start index
     * @param {module:model/String} opts.data define how to provide the data, either EMBEDED or through an URL (default to EMBEDED)
     * @param {module:model/String} opts.style define the response style. If HUMAN, the API will try to use natural reference for objects, like &#39;My First Project&#39;, &#39;Account&#39;, &#39;Total Sales&#39;... If MACHINE the API will use canonical references that are invariant, e.g. @&#39;5603ca63c531d744b50823a3bis&#39;. If LEGACY the API will also provide internal compound key to lookup objects in the management API. (default to HUMAN)
     * @param {module:model/String} opts.envelope define the result envelope
     * @param {module:api/AnalyticsApi~viewAnalysisCallback} callback The callback function, accepting three arguments: error, data, response
     */
    this.viewAnalysis = function(REFERENCE, opts, callback) {
      opts = opts || {};
      var postBody = null;

      // verify the required parameter 'REFERENCE' is set
      if (REFERENCE == undefined || REFERENCE == null) {
        throw new Error("Missing the required parameter 'REFERENCE' when calling viewAnalysis");
      }


      var pathParams = {
        'REFERENCE': REFERENCE
      };
      var queryParams = {
        'x': opts['x'],
        'y': opts['y'],
        'color': opts['color'],
        'size': opts['size'],
        'column': opts['column'],
        'row': opts['row'],
        'groupBy': this.apiClient.buildCollectionParam(opts['groupBy'], 'multi'),
        'metrics': this.apiClient.buildCollectionParam(opts['metrics'], 'multi'),
        'filters': this.apiClient.buildCollectionParam(opts['filters'], 'multi'),
        'period': opts['period'],
        'timeframe': this.apiClient.buildCollectionParam(opts['timeframe'], 'multi'),
        'compareTo': this.apiClient.buildCollectionParam(opts['compareTo'], 'multi'),
        'orderBy': this.apiClient.buildCollectionParam(opts['orderBy'], 'multi'),
        'limit': opts['limit'],
        'offset': opts['offset'],
        'beyondLimit': this.apiClient.buildCollectionParam(opts['beyondLimit'], 'multi'),
        'maxResults': opts['maxResults'],
        'startIndex': opts['startIndex'],
        'data': opts['data'],
        'style': opts['style'],
        'envelope': opts['envelope']
      };
      var headerParams = {
      };
      var formParams = {
      };

      var authNames = ['kraken_auth'];
      var contentTypes = [];
      var accepts = ['application/json'];
      var returnType = null;

      return this.apiClient.callApi(
        '/analytics/{REFERENCE}/view', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, callback
      );
    }
  };

  return exports;
}));
